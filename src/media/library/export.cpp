/**
 * Taiga
 * Copyright (C) 2010-2024, Eren Okka
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */

#include <algorithm>
#include <map>

#include "media/library/export.h"

#include "base/file.h"
#include "base/format.h"
#include "base/log.h"
#include "base/string.h"
#include "base/time.h"
#include "base/xml.h"
#include "media/anime_db.h"
#include "media/anime_item.h"
#include "media/anime_util.h"
#include "media/library/queue.h"
#include "sync/myanimelist_util.h"
#include "taiga/settings.h"
#include "taiga/version.h"
#include "ui/translate.h"

namespace library {

bool ExportAsMalXml(const std::wstring& path) {
  constexpr auto count_total_anime = []() {
    int count = 0;
    for (const auto& [id, item] : anime::db.items) {
      if (item.IsInList()) {
        count += 1;
      }
    }
    return count;
  };

  constexpr auto tr_series_type = [](anime::SeriesType type) {
    switch (type) {
      default:
      case anime::SeriesType::Unknown: return L"Unknown";
      case anime::SeriesType::Tv: return L"TV";
      case anime::SeriesType::Ova: return L"OVA";
      case anime::SeriesType::Movie: return L"Movie";
      case anime::SeriesType::Special: return L"Special";
      case anime::SeriesType::Ona: return L"ONA";
      case anime::SeriesType::Music: return L"Music";
    }
  };

  constexpr auto tr_my_status = [](anime::MyStatus status) {
    switch (status) {
      default:
      case anime::MyStatus::Watching: return L"Watching";
      case anime::MyStatus::Completed: return L"Completed";
      case anime::MyStatus::OnHold: return L"On-Hold";
      case anime::MyStatus::Dropped: return L"Dropped";
      case anime::MyStatus::PlanToWatch: return L"Plan to Watch";
    }
  };

  XmlDocument document;

  auto node_decl = document.prepend_child(pugi::node_declaration);
  node_decl.append_attribute(L"version") = L"1.0";
  node_decl.append_attribute(L"encoding") = L"UTF-8";

  auto node_comment = document.append_child(pugi::node_comment);
  node_comment.set_value(L" Generated by Taiga v{} on {} {} "_format(
      StrToWstr(taiga::version().to_string()),
      GetDate().to_string(),
      GetTime()).c_str());

  auto node_myanimelist = document.append_child(L"myanimelist");

  auto node_myinfo = node_myanimelist.append_child(L"myinfo");
  XmlWriteInt(node_myinfo, L"user_id", 0);
  XmlWriteStr(node_myinfo, L"user_name", taiga::GetCurrentUsername());
  XmlWriteInt(node_myinfo, L"user_export_type", 1);  // anime
  XmlWriteInt(node_myinfo, L"user_total_anime", count_total_anime());
  XmlWriteInt(node_myinfo, L"user_total_watching", anime::db.GetItemCount(anime::MyStatus::Watching));
  XmlWriteInt(node_myinfo, L"user_total_completed", anime::db.GetItemCount(anime::MyStatus::Completed));
  XmlWriteInt(node_myinfo, L"user_total_onhold", anime::db.GetItemCount(anime::MyStatus::OnHold));
  XmlWriteInt(node_myinfo, L"user_total_dropped", anime::db.GetItemCount(anime::MyStatus::Dropped));
  XmlWriteInt(node_myinfo, L"user_total_plantowatch", anime::db.GetItemCount(anime::MyStatus::PlanToWatch));

  for (const auto& [id, item] : anime::db.items) {
    if (item.IsInList()) {
      const auto mal_id = ToInt(item.GetId(sync::ServiceId::MyAnimeList));
      if (!mal_id) {
        LOGW(L"MAL ID unavailable for #{} ({})", id, item.GetTitle());
        continue;
      }

      auto node = node_myanimelist.append_child(L"anime");
      XmlWriteInt(node, L"series_animedb_id", mal_id);
      XmlWriteStr(node, L"series_title", item.GetTitle(), pugi::node_cdata);
      XmlWriteStr(node, L"series_type", tr_series_type(item.GetType()));
      XmlWriteInt(node, L"series_episodes", item.GetEpisodeCount());

      XmlWriteInt(node, L"my_id", 0);
      XmlWriteInt(node, L"my_watched_episodes", item.GetMyLastWatchedEpisode());
      XmlWriteStr(node, L"my_start_date", item.GetMyDateStart().to_string());
      XmlWriteStr(node, L"my_finish_date", item.GetMyDateEnd().to_string());
      XmlWriteStr(node, L"my_fansub_group", L"", pugi::node_cdata);
      XmlWriteStr(node, L"my_rated", L"");
      XmlWriteInt(node, L"my_score", sync::myanimelist::TranslateMyRatingTo(item.GetMyScore()));
      XmlWriteStr(node, L"my_dvd", L"");
      XmlWriteStr(node, L"my_storage", L"");
      XmlWriteStr(node, L"my_status", tr_my_status(item.GetMyStatus()));
      XmlWriteStr(node, L"my_comments", item.GetMyNotes(), pugi::node_cdata);
      XmlWriteInt(node, L"my_times_watched", item.GetMyRewatchedTimes());
      XmlWriteStr(node, L"my_rewatch_value", L"");
      XmlWriteInt(node, L"my_downloaded_eps", 0);
      XmlWriteStr(node, L"my_tags", L"");
      XmlWriteInt(node, L"my_rewatching", item.GetMyRewatching());
      XmlWriteInt(node, L"my_rewatching_ep", item.GetMyRewatchingEp());
      XmlWriteInt(node, L"update_on_import", library::queue.IsQueued(item.GetId()));
    }
  }

  return XmlSaveDocumentToFile(document, path);
}

bool ExportAsMarkdown(const std::wstring& path) {
  std::map<anime::MyStatus, std::vector<std::wstring>> status_lists;

  for (const auto& [id, item] : anime::db.items) {
    if (item.IsInList()) {
      status_lists[item.GetMyStatus()].push_back(L"{} ({}/{})"_format(
          anime::GetPreferredTitle(item),
          item.GetMyLastWatchedEpisode(),
          ui::TranslateNumber(item.GetEpisodeCount(), L"?")));
    }
  }

  for (auto& [status, list] : status_lists) {
    std::sort(list.begin(), list.end(),
              [](const std::wstring& a, const std::wstring& b) {
                return CompareStrings(a, b, true) < 0;
              });
  }

  std::wstring text;
  for (const auto& [status, list] : status_lists) {
    if (!text.empty())
      text += L"\r\n";
    text += L"# {}\r\n\r\n"_format(ui::TranslateMyStatus(status, true));
    for (const auto& line : list) {
      text += L"- {}\r\n"_format(line);
    }
  }

  return SaveToFile(WstrToStr(text), path, false);
}

}  // namespace library
